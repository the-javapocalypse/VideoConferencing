/**
 * @license
 * Copyright Alibaba.com All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
import { Platform } from '@angular/cdk/platform';
import { ChangeDetectorRef, ElementRef, EventEmitter, OnChanges, OnDestroy, OnInit, SimpleChanges } from '@angular/core';
import { ControlValueAccessor } from '@angular/forms';
import { ExtendedMark, NzMarks, SliderHandler, SliderShowTooltip, SliderValue } from './nz-slider-definitions';
import * as ɵngcc0 from '@angular/core';
export declare class NzSliderComponent implements ControlValueAccessor, OnInit, OnChanges, OnDestroy {
    private cdr;
    private platform;
    slider: ElementRef<HTMLDivElement>;
    nzDisabled: boolean;
    nzDots: boolean;
    nzIncluded: boolean;
    nzRange: boolean;
    nzVertical: boolean;
    nzDefaultValue: SliderValue | null;
    nzMarks: NzMarks | null;
    nzMax: number;
    nzMin: number;
    nzStep: number;
    nzTooltipVisible: SliderShowTooltip;
    nzTooltipPlacement: string;
    nzTipFormatter: (value: number) => string;
    readonly nzOnAfterChange: EventEmitter<SliderValue>;
    value: SliderValue | null;
    sliderDOM: HTMLDivElement;
    cacheSliderStart: number | null;
    cacheSliderLength: number | null;
    activeValueIndex: number | undefined;
    track: {
        offset: null | number;
        length: null | number;
    };
    handles: SliderHandler[];
    marksArray: ExtendedMark[] | null;
    bounds: {
        lower: SliderValue | null;
        upper: SliderValue | null;
    };
    isDragging: boolean;
    private dragStart$;
    private dragMove$;
    private dragEnd$;
    private dragStart_;
    private dragMove_;
    private dragEnd_;
    constructor(cdr: ChangeDetectorRef, platform: Platform);
    ngOnInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    ngOnDestroy(): void;
    writeValue(val: SliderValue | null): void;
    onValueChange(_value: SliderValue): void;
    onTouched(): void;
    registerOnChange(fn: (value: SliderValue) => void): void;
    registerOnTouched(fn: () => void): void;
    setDisabledState(isDisabled: boolean): void;
    private setValue;
    private getValue;
    /**
     * Clone & sort current value and convert them to offsets, then return the new one.
     */
    private getValueToOffset;
    /**
     * Find the closest value to be activated (only for range = true).
     */
    private setActiveValueIndex;
    private setActiveValue;
    /**
     * Update track and handles' position and length.
     */
    private updateTrackAndHandles;
    private onDragStart;
    private onDragMove;
    private onDragEnd;
    /**
     * Create user interactions handles.
     */
    private createDraggingObservables;
    private subscribeDrag;
    private unsubscribeDrag;
    private toggleDragMoving;
    private toggleDragDisabled;
    private findClosestValue;
    private valueToOffset;
    private getSliderStartPosition;
    private getSliderLength;
    /**
     * Cache DOM layout/reflow operations for performance (may not necessary?)
     */
    private cacheSliderProperty;
    private formatValue;
    /**
     * Check if value is valid and throw error if value-type/range not match.
     */
    private assertValueValid;
    /**
     * Assert that if `this.nzRange` is `true`, value is also a range, vice versa.
     */
    private assertValueTypeMatch;
    private valuesEqual;
    /**
     * Show one handle's tooltip and hide others'.
     */
    private showHandleTooltip;
    private hideAllHandleTooltip;
    private generateHandles;
    private generateMarkItems;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NzSliderComponent>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<NzSliderComponent, "nz-slider", ["nzSlider"], {
    "nzDisabled": "nzDisabled";
    "nzDots": "nzDots";
    "nzIncluded": "nzIncluded";
    "nzRange": "nzRange";
    "nzVertical": "nzVertical";
    "nzDefaultValue": "nzDefaultValue";
    "nzMarks": "nzMarks";
    "nzMax": "nzMax";
    "nzMin": "nzMin";
    "nzStep": "nzStep";
    "nzTooltipVisible": "nzTooltipVisible";
    "nzTooltipPlacement": "nzTooltipPlacement";
    "nzTipFormatter": "nzTipFormatter";
}, {
    "nzOnAfterChange": "nzOnAfterChange";
}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibnotc2xpZGVyLmNvbXBvbmVudC5kLnRzIiwic291cmNlcyI6WyJuei1zbGlkZXIuY29tcG9uZW50LmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7OztBQVdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFHQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBbGliYWJhLmNvbSBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9ORy1aT1JSTy9uZy16b3Jyby1hbnRkL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqL1xuaW1wb3J0IHsgUGxhdGZvcm0gfSBmcm9tICdAYW5ndWxhci9jZGsvcGxhdGZvcm0nO1xuaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0b3JSZWYsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgT25DaGFuZ2VzLCBPbkRlc3Ryb3ksIE9uSW5pdCwgU2ltcGxlQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBFeHRlbmRlZE1hcmssIE56TWFya3MsIFNsaWRlckhhbmRsZXIsIFNsaWRlclNob3dUb29sdGlwLCBTbGlkZXJWYWx1ZSB9IGZyb20gJy4vbnotc2xpZGVyLWRlZmluaXRpb25zJztcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE56U2xpZGVyQ29tcG9uZW50IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE9uSW5pdCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xuICAgIHByaXZhdGUgY2RyO1xuICAgIHByaXZhdGUgcGxhdGZvcm07XG4gICAgc2xpZGVyOiBFbGVtZW50UmVmPEhUTUxEaXZFbGVtZW50PjtcbiAgICBuekRpc2FibGVkOiBib29sZWFuO1xuICAgIG56RG90czogYm9vbGVhbjtcbiAgICBuekluY2x1ZGVkOiBib29sZWFuO1xuICAgIG56UmFuZ2U6IGJvb2xlYW47XG4gICAgbnpWZXJ0aWNhbDogYm9vbGVhbjtcbiAgICBuekRlZmF1bHRWYWx1ZTogU2xpZGVyVmFsdWUgfCBudWxsO1xuICAgIG56TWFya3M6IE56TWFya3MgfCBudWxsO1xuICAgIG56TWF4OiBudW1iZXI7XG4gICAgbnpNaW46IG51bWJlcjtcbiAgICBuelN0ZXA6IG51bWJlcjtcbiAgICBuelRvb2x0aXBWaXNpYmxlOiBTbGlkZXJTaG93VG9vbHRpcDtcbiAgICBuelRvb2x0aXBQbGFjZW1lbnQ6IHN0cmluZztcbiAgICBuelRpcEZvcm1hdHRlcjogKHZhbHVlOiBudW1iZXIpID0+IHN0cmluZztcbiAgICByZWFkb25seSBuek9uQWZ0ZXJDaGFuZ2U6IEV2ZW50RW1pdHRlcjxTbGlkZXJWYWx1ZT47XG4gICAgdmFsdWU6IFNsaWRlclZhbHVlIHwgbnVsbDtcbiAgICBzbGlkZXJET006IEhUTUxEaXZFbGVtZW50O1xuICAgIGNhY2hlU2xpZGVyU3RhcnQ6IG51bWJlciB8IG51bGw7XG4gICAgY2FjaGVTbGlkZXJMZW5ndGg6IG51bWJlciB8IG51bGw7XG4gICAgYWN0aXZlVmFsdWVJbmRleDogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIHRyYWNrOiB7XG4gICAgICAgIG9mZnNldDogbnVsbCB8IG51bWJlcjtcbiAgICAgICAgbGVuZ3RoOiBudWxsIHwgbnVtYmVyO1xuICAgIH07XG4gICAgaGFuZGxlczogU2xpZGVySGFuZGxlcltdO1xuICAgIG1hcmtzQXJyYXk6IEV4dGVuZGVkTWFya1tdIHwgbnVsbDtcbiAgICBib3VuZHM6IHtcbiAgICAgICAgbG93ZXI6IFNsaWRlclZhbHVlIHwgbnVsbDtcbiAgICAgICAgdXBwZXI6IFNsaWRlclZhbHVlIHwgbnVsbDtcbiAgICB9O1xuICAgIGlzRHJhZ2dpbmc6IGJvb2xlYW47XG4gICAgcHJpdmF0ZSBkcmFnU3RhcnQkO1xuICAgIHByaXZhdGUgZHJhZ01vdmUkO1xuICAgIHByaXZhdGUgZHJhZ0VuZCQ7XG4gICAgcHJpdmF0ZSBkcmFnU3RhcnRfO1xuICAgIHByaXZhdGUgZHJhZ01vdmVfO1xuICAgIHByaXZhdGUgZHJhZ0VuZF87XG4gICAgY29uc3RydWN0b3IoY2RyOiBDaGFuZ2VEZXRlY3RvclJlZiwgcGxhdGZvcm06IFBsYXRmb3JtKTtcbiAgICBuZ09uSW5pdCgpOiB2b2lkO1xuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkO1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XG4gICAgd3JpdGVWYWx1ZSh2YWw6IFNsaWRlclZhbHVlIHwgbnVsbCk6IHZvaWQ7XG4gICAgb25WYWx1ZUNoYW5nZShfdmFsdWU6IFNsaWRlclZhbHVlKTogdm9pZDtcbiAgICBvblRvdWNoZWQoKTogdm9pZDtcbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuOiAodmFsdWU6IFNsaWRlclZhbHVlKSA9PiB2b2lkKTogdm9pZDtcbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbjogKCkgPT4gdm9pZCk6IHZvaWQ7XG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZDtcbiAgICBwcml2YXRlIHNldFZhbHVlO1xuICAgIHByaXZhdGUgZ2V0VmFsdWU7XG4gICAgLyoqXG4gICAgICogQ2xvbmUgJiBzb3J0IGN1cnJlbnQgdmFsdWUgYW5kIGNvbnZlcnQgdGhlbSB0byBvZmZzZXRzLCB0aGVuIHJldHVybiB0aGUgbmV3IG9uZS5cbiAgICAgKi9cbiAgICBwcml2YXRlIGdldFZhbHVlVG9PZmZzZXQ7XG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgY2xvc2VzdCB2YWx1ZSB0byBiZSBhY3RpdmF0ZWQgKG9ubHkgZm9yIHJhbmdlID0gdHJ1ZSkuXG4gICAgICovXG4gICAgcHJpdmF0ZSBzZXRBY3RpdmVWYWx1ZUluZGV4O1xuICAgIHByaXZhdGUgc2V0QWN0aXZlVmFsdWU7XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRyYWNrIGFuZCBoYW5kbGVzJyBwb3NpdGlvbiBhbmQgbGVuZ3RoLlxuICAgICAqL1xuICAgIHByaXZhdGUgdXBkYXRlVHJhY2tBbmRIYW5kbGVzO1xuICAgIHByaXZhdGUgb25EcmFnU3RhcnQ7XG4gICAgcHJpdmF0ZSBvbkRyYWdNb3ZlO1xuICAgIHByaXZhdGUgb25EcmFnRW5kO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSB1c2VyIGludGVyYWN0aW9ucyBoYW5kbGVzLlxuICAgICAqL1xuICAgIHByaXZhdGUgY3JlYXRlRHJhZ2dpbmdPYnNlcnZhYmxlcztcbiAgICBwcml2YXRlIHN1YnNjcmliZURyYWc7XG4gICAgcHJpdmF0ZSB1bnN1YnNjcmliZURyYWc7XG4gICAgcHJpdmF0ZSB0b2dnbGVEcmFnTW92aW5nO1xuICAgIHByaXZhdGUgdG9nZ2xlRHJhZ0Rpc2FibGVkO1xuICAgIHByaXZhdGUgZmluZENsb3Nlc3RWYWx1ZTtcbiAgICBwcml2YXRlIHZhbHVlVG9PZmZzZXQ7XG4gICAgcHJpdmF0ZSBnZXRTbGlkZXJTdGFydFBvc2l0aW9uO1xuICAgIHByaXZhdGUgZ2V0U2xpZGVyTGVuZ3RoO1xuICAgIC8qKlxuICAgICAqIENhY2hlIERPTSBsYXlvdXQvcmVmbG93IG9wZXJhdGlvbnMgZm9yIHBlcmZvcm1hbmNlIChtYXkgbm90IG5lY2Vzc2FyeT8pXG4gICAgICovXG4gICAgcHJpdmF0ZSBjYWNoZVNsaWRlclByb3BlcnR5O1xuICAgIHByaXZhdGUgZm9ybWF0VmFsdWU7XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdmFsdWUgaXMgdmFsaWQgYW5kIHRocm93IGVycm9yIGlmIHZhbHVlLXR5cGUvcmFuZ2Ugbm90IG1hdGNoLlxuICAgICAqL1xuICAgIHByaXZhdGUgYXNzZXJ0VmFsdWVWYWxpZDtcbiAgICAvKipcbiAgICAgKiBBc3NlcnQgdGhhdCBpZiBgdGhpcy5uelJhbmdlYCBpcyBgdHJ1ZWAsIHZhbHVlIGlzIGFsc28gYSByYW5nZSwgdmljZSB2ZXJzYS5cbiAgICAgKi9cbiAgICBwcml2YXRlIGFzc2VydFZhbHVlVHlwZU1hdGNoO1xuICAgIHByaXZhdGUgdmFsdWVzRXF1YWw7XG4gICAgLyoqXG4gICAgICogU2hvdyBvbmUgaGFuZGxlJ3MgdG9vbHRpcCBhbmQgaGlkZSBvdGhlcnMnLlxuICAgICAqL1xuICAgIHByaXZhdGUgc2hvd0hhbmRsZVRvb2x0aXA7XG4gICAgcHJpdmF0ZSBoaWRlQWxsSGFuZGxlVG9vbHRpcDtcbiAgICBwcml2YXRlIGdlbmVyYXRlSGFuZGxlcztcbiAgICBwcml2YXRlIGdlbmVyYXRlTWFya0l0ZW1zO1xufVxuIl19